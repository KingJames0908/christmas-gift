<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Our Christmas Memory | æˆ‘ä»¬çš„ä¸“å±åœ£è¯æ ‘</title>
    <!-- å¼•å…¥æµªæ¼«å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Noto+Serif+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        .input_video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 120px; 
            height: 90px;
            border-radius: 10px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 10;
            opacity: 0.6;
            transform: scaleX(-1); /* é•œåƒ */
            display: none; /* JSåŠ è½½æˆåŠŸåæ˜¾ç¤º */
            object-fit: cover;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        /* ä¸“å±ç¥ç¦è¯­æ ·å¼ */
        #greeting-text {
            position: absolute;
            top: 15%; /* æ”¾åœ¨æ ‘çš„ä¸Šæ–¹ */
            width: 100%;
            text-align: center;
            font-family: 'Dancing Script', 'Noto Serif SC', serif; /* ä¼˜å…ˆç”¨è‰ºæœ¯å­— */
            font-size: 3rem; /* ç”µè„‘ç«¯å¤§ä¸€ç‚¹ */
            color: #FFD700;
            text-shadow: 
                0 0 10px rgba(255, 215, 0, 0.8),
                0 0 20px rgba(255, 69, 0, 0.4);
            background: linear-gradient(to bottom, #FFD700, #F0E68C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 1;
            transition: opacity 1.5s ease-in-out;
            z-index: 6;
            pointer-events: none;
        }

        /* ç§»åŠ¨ç«¯é€‚é…å­—ä½“å¤§å° */
        @media (max-width: 768px) {
            #greeting-text {
                font-size: 2rem;
                top: 20%;
                width: 90%; /* é˜²æ­¢æ–‡å­—æ¢è¡Œå¤ªä¸‘ */
                left: 5%;
            }
        }

        #loading-text {
            font-size: 24px;
            letter-spacing: 2px;
            transition: opacity 0.5s;
            max-width: 80%;
        }

        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            transform: translateX(-50%);
            font-size: 14px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 20px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 1s;
            white-space: nowrap;
        }

        .highlight {
            color: #FFD700;
            font-weight: bold;
        }

        /* ç®€å•çš„ä¸Šä¼ æŒ‰é’®ï¼Œç”¨äºæœ¬åœ°æµ‹è¯• */
        #upload-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #FFD700;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: 0.3s;
        }
        #upload-btn:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        /* éšè—æ–‡ä»¶è¾“å…¥ */
        #file-input {
            display: none;
        }
        
        /* é¡µç æç¤º */
        #page-indicator {
            position: absolute;
            top: 10%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 215, 0, 0.8);
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 5;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
    </style>
</head>
<body>

    <!-- è§†é¢‘è¾“å…¥æµ -->
    <video class="input_video" playsinline autoplay muted></video>

    <!-- 3D å®¹å™¨ -->
    <div id="canvas-container"></div>

    <!-- UI å±‚ -->
    <div id="ui-layer">
        <div id="loading-text">æ­£åœ¨ç¼–ç»‡å›å¿†...<br><span style="font-size:14px; color:#aaa;">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯æ‰‹åŠ¿é­”æ³•</span></div>
    </div>
    
    <!-- ç¥ç¦è¯­ -->
    <div id="greeting-text">ç¥æˆ‘çš„è€å©†-å©§å®åœ£è¯èŠ‚å¿«ä¹</div>

    <div id="page-indicator">ç¬¬ 1 ç»„å›å¿†</div>

    <div id="instructions">
        âœŠ <b>æ¡æ‹³</b>: æ”¶çº³å›å¿† | ğŸ–ï¸ <b>å¼ å¼€äº”æŒ‡</b>: å±•ç¤ºä¸‹ä¸€ç»„ç…§ç‰‡ (6å¼ )
    </div>

    <!-- å›¾ç‰‡ä¸Šä¼  (æµ‹è¯•ç”¨) -->
    <button id="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ æˆ‘ä»¬çš„ç…§ç‰‡</button>
    <input type="file" id="file-input" multiple accept="image/*">

    <!-- å¼•å…¥åº“ -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
    <!-- MediaPipe Hands -->
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script>
        // --- ç”¨æˆ·é…ç½®åŒº ---
        // æ‚¨æä¾›çš„æœ¬åœ°ç…§ç‰‡åˆ—è¡¨ (50å¼ )
        const BASE_PHOTOS = [
            'IMG_20250817_212036.jpg',
            'IMG_20250818_203221.jpg',
            'IMG_20250818_203308.jpg',
            'IMG_20250823_155336.jpg',
            'IMG_20250826_093345_1.jpg',
            'IMG_20250826_141047.jpg',
            'IMG_20250828_121826.jpg',
            'IMG_20250828_133111.jpg',
            'IMG_20250828_192257.jpg',
            'IMG_20250828_192318_2.jpg',
            'IMG_20250828_213506.jpg',
            'IMG_20250828_213537.jpg',
            'IMG_20250828_214233.jpg',
            'IMG_20250829_195014.jpg',
            'IMG_20250830_094313.jpg',
            'IMG_20250830_115701_1.jpg',
            'IMG_20250830_134306.jpg',
            'IMG_20250831_122417_1.jpg',
            'IMG_20250901_072530.jpg',
            'IMG_20250901_170634.jpg',
            'IMG_20250910_132832.jpg',
            'IMG_20250913_155149.jpg',
            'IMG_20250913_202314.jpg',
            'IMG_20250913_235210.jpg',
            'IMG_20250914_123038.jpg',
            'IMG_20250914_140112.jpg',
            'IMG_20250914_173305.jpg',
            'IMG_20250914_193830.jpg',
            'IMG_20250914_200834.jpg',
            'IMG_20250914_200841.jpg',
            'IMG_20250915_191124.jpg',
            'IMG_20250915_191130.jpg',
            'IMG_20250915_191205.jpg',
            'IMG_20250915_192632.jpg',
            'IMG_20250915_192726.jpg',
            'IMG_20250915_221557_1.jpg',
            'IMG_20250915_221722.jpg',
            'IMG_20250915_222110.jpg',
            'IMG_20250916_012235.jpg',
            'IMG_20250916_143843.jpg',
            'IMG_20250916_155806.jpg',
            'IMG_20250916_161514.jpg',
            'IMG_20250916_184105.jpg',
            'IMG_20250917_164532.jpg',
            'IMG_20251002_095148.jpg',
            'IMG_20251002_163205.jpg',
            'IMG_20251002_171104.jpg',
            'IMG_20251002_180259_1.jpg',
            'IMG_20251005_130418.jpg',
            'IMG_20251006_105451.jpg'
        ];
        // æ—¢ç„¶ç…§ç‰‡è¶³å¤Ÿå¤šï¼ˆ50å¼ ï¼‰ï¼Œå°±ä¸éœ€è¦å¤åˆ¶æ‰©å……äº†
        const PRELOADED_PHOTOS = BASE_PHOTOS;

        // --- å…¨å±€å˜é‡ ---
        let scene, camera, renderer, clock;
        let particles, geometry, material;
        let photoMeshGroup = new THREE.Group();
        let photoMeshes = [];
        let currentState = 'TREE'; // 'TREE', 'CLOUD'
        
        // æ ¸å¿ƒä¿®æ”¹ï¼šç…§ç‰‡æ‰¹æ¬¡ç´¢å¼•
        let photoBatchIndex = 0; 
        const PHOTOS_PER_BATCH = 6;

        // è£…é¥°ç‰© InstancedMesh
        let ornamentsMesh; 
        
        // æ‰‹åŠ¿ç›¸å…³
        let lastGesture = 'NONE';
        let gestureDebounce = 0;
        let isCameraRunning = false;

        // é¢œè‰²é…ç½®
        const COLORS = {
            green: new THREE.Color(0x2F5A3F),
            gold: new THREE.Color(0xFFD700),
            red: new THREE.Color(0xB22222),
            snow: new THREE.Color(0xFFFFFF)
        };

        // --- åˆå§‹åŒ– Three.js ---
        function init() {
            const container = document.getElementById('canvas-container');
            
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x050510, 0.02);
            scene.background = new THREE.Color(0x050510);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(0, 0, 15);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.shadowMap.enabled = true;
            container.appendChild(renderer.domElement);

            clock = new THREE.Clock();

            // ç¯å…‰
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
            scene.add(ambientLight);

            const pointLight = new THREE.PointLight(0xFFD700, 1, 50);
            pointLight.position.set(5, 10, 5);
            scene.add(pointLight);
            
            const spotLight = new THREE.SpotLight(0xff0000, 2);
            spotLight.position.set(-5, 10, 0);
            scene.add(spotLight);

            // åˆ›å»ºåœºæ™¯å…ƒç´ 
            createSnow();
            createTreeParticles();
            createOrnaments();
            loadPhotos(PRELOADED_PHOTOS);

            window.addEventListener('resize', onWindowResize, false);
            animate();
            startCamera();
        }

        // --- 5B: é£˜é›ªå†¬å¤œ ---
        let snowSystem;
        function createSnow() {
            const snowCount = 2000;
            const snowGeo = new THREE.BufferGeometry();
            const positions = [];
            const velocities = [];

            for(let i=0; i<snowCount; i++) {
                positions.push(
                    (Math.random() - 0.5) * 50,
                    Math.random() * 30, 
                    (Math.random() - 0.5) * 50
                );
                velocities.push(
                    (Math.random() - 0.5) * 0.05,
                    -(Math.random() * 0.05 + 0.02),
                    (Math.random() - 0.5) * 0.05
                );
            }

            snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            snowGeo.userData = { velocities: velocities };

            const canvas = document.createElement('canvas');
            canvas.width = 32; canvas.height = 32;
            const ctx = canvas.getContext('2d');
            ctx.beginPath();
            ctx.arc(16, 16, 10, 0, 2 * Math.PI);
            ctx.fillStyle = '#ffffff';
            ctx.fill();
            const texture = new THREE.CanvasTexture(canvas);

            const snowMat = new THREE.PointsMaterial({
                color: 0xffffff,
                size: 0.2,
                map: texture,
                transparent: true,
                opacity: 0.6,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            snowSystem = new THREE.Points(snowGeo, snowMat);
            scene.add(snowSystem);
        }

        function updateSnow() {
            if(!snowSystem) return;
            const positions = snowSystem.geometry.attributes.position.array;
            const vels = snowSystem.geometry.userData.velocities;

            for(let i=0; i < positions.length / 3; i++) {
                positions[i*3] += vels[i*3];
                positions[i*3+1] += vels[i*3+1];
                positions[i*3+2] += vels[i*3+2];
                if(positions[i*3+1] < -10) positions[i*3+1] = 20;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
        }

        // --- 4B: ç²’å­æ˜Ÿå°˜æ ‘ ---
        function createTreeParticles() {
            const particleCount = 3000;
            const geo = new THREE.BufferGeometry();
            const positions = [];
            const colors = [];
            const treePos = [];  // å­˜å‚¨æ ‘å½¢æ€çš„ç›®æ ‡ä½ç½®
            const cloudPos = []; // å­˜å‚¨æ•£å¼€å½¢æ€çš„ç›®æ ‡ä½ç½®

            const colorGreen = COLORS.green;
            const colorGold = COLORS.gold;

            for(let i=0; i<particleCount; i++) {
                // 1. è®¡ç®—æ ‘å½¢æ€ (åœ†é”¥èºæ—‹)
                const t = i / particleCount; 
                const angle = t * Math.PI * 40; 
                const radius = t * 4; 
                const height = (1 - t) * 12 - 6; 
                
                const randomR = Math.random() * 0.5;
                const xTree = (radius + randomR) * Math.cos(angle);
                const zTree = (radius + randomR) * Math.sin(angle);
                const yTree = height;

                treePos.push(xTree, yTree, zTree);

                // 2. è®¡ç®—äº‘å½¢æ€ (èƒŒæ™¯å¾®ç²’ï¼Œä¸æŠ¢æˆ)
                const xCloud = (Math.random() - 0.5) * 40;
                const yCloud = (Math.random() - 0.5) * 30;
                const zCloud = (Math.random() - 0.5) * 20 - 5; // ç¨å¾®é å
                cloudPos.push(xCloud, yCloud, zCloud);

                positions.push(xTree, yTree, zTree);

                const mixedColor = Math.random() > 0.8 ? colorGold : colorGreen;
                colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
            }

            geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
            geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
            geo.userData = { treePos: treePos, cloudPos: cloudPos };

            const shaderMaterial = new THREE.ShaderMaterial({
                uniforms: {
                    time: { value: 0 },
                    pixelRatio: { value: window.devicePixelRatio },
                    color: { value: new THREE.Color(0xffffff) }
                },
                vertexShader: `
                    uniform float time;
                    uniform float pixelRatio;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (4.0 + 2.0 * sin(time * 2.0)) * pixelRatio * (50.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
                fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        float strength = 1.0 - (length(coord) * 2.0);
                        strength = pow(strength, 1.5);
                        gl_FragColor = vec4(vColor, strength * 0.8);
                    }
                `,
                transparent: true,
                depthWrite: false,
                blending: THREE.AdditiveBlending
            });

            particles = new THREE.Points(geo, shaderMaterial);
            scene.add(particles);
        }

        // --- è£…é¥°ç‰© ---
        function createOrnaments() {
            const count = 200;
            const geom = new THREE.IcosahedronGeometry(0.2, 0);
            const mat = new THREE.MeshStandardMaterial({ 
                color: COLORS.red, 
                roughness: 0.2, 
                metalness: 0.8 
            });
            ornamentsMesh = new THREE.InstancedMesh(geom, mat, count);
            const dummy = new THREE.Object3D();
            
            for(let i=0; i<count; i++) {
                const h = Math.random() * 10 - 5; 
                const r = (5 - (h + 5)) * 0.4 + 0.5;
                const theta = Math.random() * Math.PI * 2;
                dummy.position.set(r * Math.cos(theta), h, r * Math.sin(theta));
                dummy.updateMatrix();
                ornamentsMesh.setMatrixAt(i, dummy.matrix);
            }
            scene.add(ornamentsMesh);
        }

        // --- æ‹ç«‹å¾—ç…§ç‰‡é€»è¾‘ ---
        function createPolaroid(texture, index) {
            const group = new THREE.Group();
            
            const frameGeo = new THREE.BoxGeometry(1.8, 2.2, 0.05);
            const frameMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
            const frame = new THREE.Mesh(frameGeo, frameMat);
            
            const photoGeo = new THREE.PlaneGeometry(1.6, 1.6);
            const photoMat = new THREE.MeshBasicMaterial({ map: texture });
            const photo = new THREE.Mesh(photoGeo, photoMat);
            photo.position.z = 0.03;
            photo.position.y = 0.2;
            
            const trimGeo = new THREE.PlaneGeometry(1.6, 0.02);
            const trimMat = new THREE.MeshStandardMaterial({ color: COLORS.gold, metalness: 1, roughness: 0.2 });
            const trim = new THREE.Mesh(trimGeo, trimMat);
            trim.position.set(0, -0.7, 0.04);

            group.add(frame);
            group.add(photo);
            group.add(trim);

            group.position.set(0, -100, 0);
            
            // æ ‘çŠ¶æ€ä½ç½®
            // ç”±äºç°åœ¨æœ‰ 50 å¼ ç…§ç‰‡ï¼Œæˆ‘ä»¬éœ€è¦è®©èºæ—‹æ›´ç´§å¯†æˆ–è€…æ›´é•¿
            // ç¨å¾®è°ƒæ•´ä¸€ä¸‹åˆ†å¸ƒç®—æ³•ï¼Œè®©50å¼ ç…§ç‰‡å‡åŒ€åˆ†å¸ƒåœ¨æ ‘ä¸Š
            const totalPhotos = 50;
            const turns = 12; // åœˆæ•°å¢åŠ 
            const angle = (index / totalPhotos) * Math.PI * 2 * turns; 
            
            // åŠå¾„ä»ä¸‹åˆ°ä¸Šé€’å‡
            const normalizedH = (index / totalPhotos) * 12 - 6; // y: -6 åˆ° 6
            // åŠå¾„æ ¹æ®é«˜åº¦å˜åŒ–ï¼šåº•éƒ¨å®½ï¼Œé¡¶éƒ¨çª„ (åœ†é”¥)
            // ç®€å•çš„åœ†é”¥æ–¹ç¨‹ r = (top - y) * factor
            // æˆ‘ä»¬çš„yèŒƒå›´æ˜¯ -6 åˆ° 6ï¼Œ å‡è®¾åº•éƒ¨åŠå¾„ 5ï¼Œé¡¶éƒ¨ 0
            const r = (6 - normalizedH) * 0.5; 
            
            group.userData.treePos = {
                x: Math.cos(angle) * r,
                y: normalizedH,
                z: Math.sin(angle) * r,
                rotX: 0,
                rotY: -angle + Math.PI/2,
                rotZ: 0,
                scale: 0.35 // ç…§ç‰‡å¤šï¼Œç¨å¾®å†å°ä¸€ç‚¹ç‚¹
            };

            return group;
        }

        function loadPhotos(urls) {
            const loader = new THREE.TextureLoader();
            photoMeshes.forEach(m => scene.remove(m));
            photoMeshes = [];
            photoMeshGroup = new THREE.Group();
            scene.add(photoMeshGroup);

            urls.forEach((url, index) => {
                loader.load(url, (tex) => {
                    const mesh = createPolaroid(tex, index);
                    photoMeshes.push(mesh);
                    photoMeshGroup.add(mesh);
                    // åˆå§‹ä½ç½®
                    mesh.position.set(
                        mesh.userData.treePos.x,
                        mesh.userData.treePos.y,
                        mesh.userData.treePos.z
                    );
                    mesh.rotation.y = mesh.userData.treePos.rotY;
                    mesh.scale.set(0.35, 0.35, 0.35);
                });
            });
        }

        // æ–‡ä»¶ä¸Šä¼ å¤„ç†
        document.getElementById('file-input').addEventListener('change', function(e) {
            const files = e.target.files;
            if(files.length === 0) return;
            const newUrls = [];
            for(let i=0; i<files.length; i++) {
                newUrls.push(URL.createObjectURL(files[i]));
            }
            // é‡æ–°é‡ç½®ç´¢å¼•
            photoBatchIndex = 0;
            loadPhotos(newUrls);
        });

        // --- æ ¸å¿ƒï¼šçŠ¶æ€æœºä¸å¸ƒå±€è®¡ç®— ---
        function updateState(newState, force = false) {
            if (currentState === newState && !force) return;
            
            // å¦‚æœæ˜¯ä» CLOUD å˜å› TREEï¼Œæ›´æ–°ä¸‹ä¸€è½®çš„èµ·å§‹ç´¢å¼•
            if (currentState === 'CLOUD' && newState === 'TREE') {
                photoBatchIndex = (photoBatchIndex + PHOTOS_PER_BATCH) % photoMeshes.length;
                
                // éšè—é¡µç ï¼Œæ˜¾ç¤ºç¥ç¦è¯­
                document.getElementById('page-indicator').style.opacity = 0;
                document.getElementById('greeting-text').style.opacity = 1;
            }

            if (newState === 'CLOUD') {
                // æ˜¾ç¤ºé¡µç ï¼Œéšè—ç¥ç¦è¯­
                const pageNum = Math.floor(photoBatchIndex / PHOTOS_PER_BATCH) + 1;
                document.getElementById('page-indicator').innerText = `ç¬¬ ${pageNum} ç»„å›å¿†`;
                document.getElementById('page-indicator').style.opacity = 1;
                document.getElementById('greeting-text').style.opacity = 0;
            }

            currentState = newState;
            const duration = 1.2;
            const ease = "power2.inOut";

            // 1. ç²’å­åŠ¨ç”» (åªéœ€æ”¹å˜ä½ç½®æ’å€¼)
            const pPositions = particles.geometry.attributes.position.array;
            const targetKey = newState === 'TREE' ? 'treePos' : 'cloudPos';
            const targets = particles.geometry.userData[targetKey];
            const startPos = Float32Array.from(pPositions);
            const animObj = { val: 0 };
            
            gsap.to(animObj, {
                val: 1,
                duration: duration,
                ease: ease,
                onUpdate: () => {
                    for(let i=0; i < pPositions.length; i++) {
                        pPositions[i] = startPos[i] + (targets[i] - startPos[i]) * animObj.val;
                    }
                    particles.geometry.attributes.position.needsUpdate = true;
                }
            });

            // 2. è£…é¥°ç‰©åŠ¨ç”»
            if(newState === 'TREE') {
                gsap.to(ornamentsMesh.scale, { x: 1, y: 1, z: 1, duration: duration });
                gsap.to(ornamentsMesh.position, { y: 0, duration: duration });
            } else {
                gsap.to(ornamentsMesh.scale, { x: 0, y: 0, z: 0, duration: duration });
            }

            // 3. ç…§ç‰‡åŠ¨ç”» (æ ¸å¿ƒä¿®æ”¹ï¼šåŠ¨æ€ç½‘æ ¼å¸ƒå±€)
            
            // è®¡ç®—å½“å‰éœ€è¦æ˜¾ç¤ºçš„ 6 ä¸ªç´¢å¼•
            const activeIndices = [];
            for(let i = 0; i < PHOTOS_PER_BATCH; i++) {
                activeIndices.push((photoBatchIndex + i) % photoMeshes.length);
            }

            // æ£€æµ‹å±å¹•æ¯”ä¾‹
            const isPortrait = window.innerHeight > window.innerWidth;
            const cols = isPortrait ? 2 : 3;
            // const rows = isPortrait ? 3 : 2;
            
            // ç½‘æ ¼å‚æ•°
            const spacingX = isPortrait ? 3.5 : 5.0;
            const spacingY = isPortrait ? 4.5 : 4.0;
            // è·ç¦»æ‘„åƒæœº(z=15)è¿‘ä¸€ç‚¹ï¼Œæ˜¾å¾—å¤§
            const targetZ = 10; 
            const targetScale = isPortrait ? 1.3 : 1.5;

            photoMeshes.forEach((mesh, index) => {
                let target = {};

                if (newState === 'TREE') {
                    // å›åˆ°æ ‘ä¸Š
                    target = {
                        x: mesh.userData.treePos.x,
                        y: mesh.userData.treePos.y,
                        z: mesh.userData.treePos.z,
                        rotX: 0,
                        rotY: mesh.userData.treePos.rotY,
                        rotZ: 0,
                        scale: 0.35
                    };
                } else {
                    // CLOUD çŠ¶æ€
                    const slotIndex = activeIndices.indexOf(index);
                    
                    if (slotIndex !== -1) {
                        // åœ¨å½“å‰å±•ç¤ºæ‰¹æ¬¡ä¸­ï¼Œè®¡ç®—ç½‘æ ¼ä½ç½®
                        // åæ ‡ç³»ä¸­å¿ƒ (0,0)
                        const col = slotIndex % cols;
                        const row = Math.floor(slotIndex / cols);
                        
                        // è®¡ç®—åç§»ï¼Œä½¿ç½‘æ ¼å±…ä¸­
                        // total width = (cols-1) * spacingX
                        // startX = - total width / 2
                        const startX = -((cols - 1) * spacingX) / 2;
                        // total height = ...
                        // startY = + total height / 2 (ä»ä¸Šå¾€ä¸‹æ’)
                        // ä½†æ˜¯ 3D åæ ‡ y æ˜¯å‘ä¸Šä¸ºæ­£ï¼Œæ‰€ä»¥ row 0 åº”è¯¥æ˜¯é«˜ y
                        const rowsTotal = Math.ceil(PHOTOS_PER_BATCH / cols);
                        const startY = ((rowsTotal - 1) * spacingY) / 2;

                        target = {
                            x: startX + col * spacingX,
                            y: startY - row * spacingY, // row å¢åŠ ï¼Œy å‡å°
                            z: targetZ,
                            rotX: 0, 
                            rotY: 0, 
                            rotZ: 0,
                            scale: targetScale
                        };
                    } else {
                        // ä¸åœ¨å½“å‰æ‰¹æ¬¡ï¼Œéšè—æ‰
                        target = {
                            x: mesh.userData.treePos.x * 5, // é£åˆ°è¿œå¤„
                            y: mesh.userData.treePos.y * 5,
                            z: -20, // æ”¾åˆ°ç›¸æœºåé¢æˆ–è€…å¾ˆè¿œ
                            rotX: 0, rotY: 0, rotZ: 0,
                            scale: 0 // ç¼©æ”¾ä¸º0ä¸å¯è§
                        };
                    }
                }

                // æ‰§è¡ŒåŠ¨ç”»
                gsap.to(mesh.position, {
                    x: target.x,
                    y: target.y,
                    z: target.z,
                    duration: duration,
                    ease: ease
                });
                gsap.to(mesh.rotation, {
                    x: target.rotX,
                    y: target.rotY,
                    z: target.rotZ,
                    duration: duration,
                    ease: ease
                });
                gsap.to(mesh.scale, {
                    x: target.scale,
                    y: target.scale,
                    z: target.scale,
                    duration: duration,
                    ease: ease
                });
            });
        }

        // --- æ‰‹åŠ¿è¯†åˆ«é€»è¾‘ ---
        const videoElement = document.getElementsByClassName('input_video')[0];

        function onResults(results) {
            document.getElementById('loading-text').style.display = 'none';
            document.getElementById('instructions').style.opacity = 1;
            document.querySelector('.input_video').style.display = 'block';

            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const wrist = landmarks[0];
                const tips = [8, 12, 16, 20].map(i => landmarks[i]);
                const dist = tips.reduce((acc, t) => acc + d(wrist, t), 0) / 4;
                
                let gesture = 'UNKNOWN';
                if (dist < 0.25) gesture = 'FIST';
                else if (dist > 0.4) gesture = 'OPEN';

                // ç®€å•çš„å»æŠ–åŠ¨
                const now = Date.now();
                if (now - gestureDebounce > 500) {
                    if (gesture === 'FIST' && lastGesture !== 'FIST') {
                        // æ¡æ‹³ -> å˜æˆæ ‘ (å¹¶è§¦å‘ç´¢å¼•æ›´æ–°çš„å‡†å¤‡)
                        updateState('TREE');
                        gestureDebounce = now;
                    } else if (gesture === 'OPEN' && currentState === 'TREE') {
                        // å¼ æ‰‹ -> å˜æˆäº‘ (å±•ç¤ºå½“å‰ç´¢å¼•çš„é‚£ç»„ç…§ç‰‡)
                        updateState('CLOUD');
                        gestureDebounce = now;
                    }
                    if (gesture !== 'UNKNOWN') lastGesture = gesture;
                }
            }
        }

        function d(p1, p2) {
            return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
        }

        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
        hands.onResults(onResults);

        async function startCamera() {
            if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                showError("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ã€‚");
                return;
            }
            try {
                const stream = await navigator.mediaDevices.getUserMedia({
                    video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: "user" }
                });
                videoElement.srcObject = stream;
                videoElement.onloadedmetadata = () => {
                    videoElement.play();
                    isCameraRunning = true;
                    processVideoLoop(); 
                };
            } catch (error) {
                console.error(error);
                showError("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚");
            }
        }

        function showError(msg) {
            document.getElementById('loading-text').innerHTML = msg;
        }

        async function processVideoLoop() {
            if (!isCameraRunning) return;
            if (videoElement.readyState >= 2) {
                try { await hands.send({image: videoElement}); } catch (e) {}
            }
            requestAnimationFrame(processVideoLoop);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = clock.getElapsedTime();
            if(particles && particles.material.uniforms) particles.material.uniforms.time.value = time;
            
            // æ ‘çŠ¶æ€è‡ªè½¬
            if (currentState === 'TREE' && scene) scene.rotation.y = time * 0.1;
            // äº‘çŠ¶æ€å¾®åŠ¨
            if (currentState === 'CLOUD' && scene) scene.rotation.y = Math.sin(time * 0.2) * 0.02;

            updateSnow();
            renderer.render(scene, camera);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            if(particles) particles.material.uniforms.pixelRatio.value = window.devicePixelRatio;
            
            // çª—å£æ”¹å˜æ—¶å¦‚æœæ­£åœ¨å±•ç¤ºï¼Œå¼ºåˆ¶åˆ·æ–°å¸ƒå±€
            if(currentState === 'CLOUD') updateState('CLOUD', true);
        }

        init();
    </script>
</body>
</html>