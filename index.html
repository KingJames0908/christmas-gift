<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Our Christmas Memory | æˆ‘ä»¬çš„ä¸“å±åœ£è¯æ ‘</title>
    <!-- å¼•å…¥æµªæ¼«å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Noto+Serif+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        .input_video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 100px; /* æ‰‹æœºä¸Šæ”¹å°ä¸€ç‚¹ */
            height: 75px;
            border-radius: 8px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 10;
            opacity: 0.6;
            transform: scaleX(-1); /* é•œåƒ */
            display: none; /* JSåŠ è½½æˆåŠŸåæ˜¾ç¤º */
            object-fit: cover;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 5;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            text-align: center;
            color: #fff;
            text-shadow: 0 0 10px rgba(255, 215, 0, 0.8);
        }

        /* ä¸“å±ç¥ç¦è¯­æ ·å¼ */
        #greeting-text {
            position: absolute;
            top: 18%; /* æ‰‹æœºä¸Šç¨å¾®å¾€ä¸‹ä¸€ç‚¹ */
            width: 90%;
            left: 5%;
            text-align: center;
            font-family: 'Dancing Script', 'Noto Serif SC', serif;
            font-size: 2.2rem; /* æ‰‹æœºå­—ä½“å¤§å°è°ƒæ•´ */
            line-height: 1.4;
            color: #FFD700;
            text-shadow:
                    0 0 10px rgba(255, 215, 0, 0.8),
                    0 0 20px rgba(255, 69, 0, 0.4);
            background: linear-gradient(to bottom, #FFD700, #F0E68C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 1;
            transition: opacity 1.5s ease-in-out;
            z-index: 6;
            pointer-events: none;
        }

        #loading-text {
            font-size: 20px;
            letter-spacing: 2px;
            transition: opacity 0.5s;
            max-width: 80%;
        }

        #instructions {
            position: absolute;
            bottom: 30px;
            left: 50%;
            width: 90%;
            transform: translateX(-50%);
            font-size: 13px;
            color: rgba(255, 255, 255, 0.7);
            background: rgba(0, 0, 0, 0.5);
            padding: 10px 10px;
            border-radius: 20px;
            opacity: 0;
            transition: opacity 1s;
            white-space: nowrap;
            text-align: center;
        }

        .highlight {
            color: #FFD700;
            font-weight: bold;
        }

        /* ç®€å•çš„ä¸Šä¼ æŒ‰é’®ï¼Œç”¨äºæœ¬åœ°æµ‹è¯• */
        #upload-btn {
            position: absolute;
            top: 20px;
            right: 20px;
            z-index: 20;
            pointer-events: auto;
            background: rgba(255, 255, 255, 0.1);
            border: 1px solid rgba(255, 215, 0, 0.5);
            color: #FFD700;
            padding: 8px 15px;
            border-radius: 5px;
            cursor: pointer;
            font-size: 12px;
            transition: 0.3s;
        }
        #upload-btn:hover {
            background: rgba(255, 215, 0, 0.2);
        }

        /* éšè—æ–‡ä»¶è¾“å…¥ */
        #file-input {
            display: none;
        }

        /* é¡µç æç¤º */
        #page-indicator {
            position: absolute;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 215, 0, 0.8);
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 5;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }
    </style>
</head>
<body>

<!-- è§†é¢‘è¾“å…¥æµ -->
<video class="input_video" playsinline autoplay muted></video>

<!-- 3D å®¹å™¨ -->
<div id="canvas-container"></div>

<!-- UI å±‚ -->
<div id="ui-layer">
    <div id="loading-text">æ­£åœ¨ç¼–ç»‡å›å¿†...<br><span style="font-size:14px; color:#aaa;">è¯·å…è®¸æ‘„åƒå¤´æƒé™ä»¥å¼€å¯æ‰‹åŠ¿é­”æ³•</span></div>
</div>

<!-- ç¥ç¦è¯­ -->
<div id="greeting-text">ç¥æˆ‘çš„è€å©†-å©§å®<br>åœ£è¯èŠ‚å¿«ä¹</div>

<div id="page-indicator">ç¬¬ 1 ç»„å›å¿†</div>

<div id="instructions">
    âœŠ <b>æ¡æ‹³</b>: æ”¶çº³ | ğŸ–ï¸ <b>å¼ æ‰‹</b>: ä¸‹ä¸€ç»„ (6å¼ )
</div>

<!-- å›¾ç‰‡ä¸Šä¼  (æµ‹è¯•ç”¨) -->
<button id="upload-btn" onclick="document.getElementById('file-input').click()">ä¸Šä¼ æˆ‘ä»¬çš„ç…§ç‰‡</button>
<input type="file" id="file-input" multiple accept="image/*">

<!-- å¼•å…¥åº“ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- ç”¨æˆ·é…ç½®åŒº ---
    const BASE_PHOTOS = [
        'IMG_20250817_212036.jpg',
        'IMG_20250818_203221.jpg',
        'IMG_20250818_203308.jpg',
        'IMG_20250823_155336.jpg',
        'IMG_20250826_093345_1.jpg',
        'IMG_20250826_141047.jpg',
        'IMG_20250828_121826.jpg',
        'IMG_20250828_133111.jpg',
        'IMG_20250828_192257.jpg',
        'IMG_20250828_192318_2.jpg',
        'IMG_20250828_213506.jpg',
        'IMG_20250828_213537.jpg',
        'IMG_20250828_214233.jpg',
        'IMG_20250829_195014.jpg',
        'IMG_20250830_094313.jpg',
        'IMG_20250830_115701_1.jpg',
        'IMG_20250830_134306.jpg',
        'IMG_20250831_122417_1.jpg',
        'IMG_20250901_072530.jpg',
        'IMG_20250901_170634.jpg',
        'IMG_20250910_132832.jpg',
        'IMG_20250913_155149.jpg',
        'IMG_20250913_202314.jpg',
        'IMG_20250913_235210.jpg',
        'IMG_20250914_123038.jpg',
        'IMG_20250914_140112.jpg',
        'IMG_20250914_173305.jpg',
        'IMG_20250914_193830.jpg',
        'IMG_20250914_200834.jpg',
        'IMG_20250914_200841.jpg',
        'IMG_20250915_191124.jpg',
        'IMG_20250915_191130.jpg',
        'IMG_20250915_191205.jpg',
        'IMG_20250915_192632.jpg',
        'IMG_20250915_192726.jpg',
        'IMG_20250915_221557_1.jpg',
        'IMG_20250915_221722.jpg',
        'IMG_20250915_222110.jpg',
        'IMG_20250916_012235.jpg',
        'IMG_20250916_143843.jpg',
        'IMG_20250916_155806.jpg',
        'IMG_20250916_161514.jpg',
        'IMG_20250916_184105.jpg',
        'IMG_20250917_164532.jpg',
        'IMG_20251002_095148.jpg',
        'IMG_20251002_163205.jpg',
        'IMG_20251002_171104.jpg',
        'IMG_20251002_180259_1.jpg',
        'IMG_20251005_130418.jpg',
        'IMG_20251006_105451.jpg'
    ];
    const PRELOADED_PHOTOS = BASE_PHOTOS;

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, clock;
    let particles, geometry, material;
    let photoMeshGroup = new THREE.Group();
    let photoMeshes = [];
    let currentState = 'TREE'; // 'TREE', 'CLOUD'

    let photoBatchIndex = 0;
    const PHOTOS_PER_BATCH = 6;

    let ornamentsMesh;
    let lastGesture = 'NONE';
    let gestureDebounce = 0;
    let isCameraRunning = false;

    const COLORS = {
        green: new THREE.Color(0x2F5A3F),
        gold: new THREE.Color(0xFFD700),
        red: new THREE.Color(0xB22222),
        snow: new THREE.Color(0xFFFFFF)
    };

    // --- åˆå§‹åŒ– Three.js ---
    function init() {
        const container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02);
        scene.background = new THREE.Color(0x050510);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        // æ ¸å¿ƒä¿®æ”¹ï¼šé’ˆå¯¹æ‰‹æœºç«–å±ï¼Œå¤§å¹…æ‹‰è¿œç›¸æœºè·ç¦»
        // ç”µè„‘é»˜è®¤æ˜¯15ï¼Œæ‰‹æœºæˆ‘ä»¬éœ€è¦ç»™åˆ° 24 ç”šè‡³æ›´è¿œï¼Œæ‰èƒ½æ”¾ä¸‹ 2åˆ—
        if(window.innerWidth < window.innerHeight) {
            camera.position.set(0, 0, 24);
        } else {
            camera.position.set(0, 0, 16);
        }

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);

        const pointLight = new THREE.PointLight(0xFFD700, 1, 50);
        pointLight.position.set(5, 10, 5);
        scene.add(pointLight);

        const spotLight = new THREE.SpotLight(0xff0000, 2);
        spotLight.position.set(-5, 10, 0);
        scene.add(spotLight);

        // åˆ›å»ºåœºæ™¯å…ƒç´ 
        createSnow();
        createTreeParticles();
        createOrnaments();
        loadPhotos(PRELOADED_PHOTOS);

        window.addEventListener('resize', onWindowResize, false);
        animate();
        startCamera();
    }

    // --- 5B: é£˜é›ªå†¬å¤œ ---
    let snowSystem;
    function createSnow() {
        const snowCount = 2000;
        const snowGeo = new THREE.BufferGeometry();
        const positions = [];
        const velocities = [];

        for(let i=0; i<snowCount; i++) {
            positions.push(
                (Math.random() - 0.5) * 50,
                Math.random() * 30,
                (Math.random() - 0.5) * 50
            );
            velocities.push(
                (Math.random() - 0.5) * 0.05,
                -(Math.random() * 0.05 + 0.02),
                (Math.random() - 0.5) * 0.05
            );
        }

        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        snowGeo.userData = { velocities: velocities };

        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(16, 16, 10, 0, 2 * Math.PI);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        const texture = new THREE.CanvasTexture(canvas);

        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff,
            size: 0.2,
            map: texture,
            transparent: true,
            opacity: 0.6,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);
    }

    function updateSnow() {
        if(!snowSystem) return;
        const positions = snowSystem.geometry.attributes.position.array;
        const vels = snowSystem.geometry.userData.velocities;

        for(let i=0; i < positions.length / 3; i++) {
            positions[i*3] += vels[i*3];
            positions[i*3+1] += vels[i*3+1];
            positions[i*3+2] += vels[i*3+2];
            if(positions[i*3+1] < -10) positions[i*3+1] = 20;
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    // --- 4B: ç²’å­æ˜Ÿå°˜æ ‘ ---
    function createTreeParticles() {
        const particleCount = 3000;
        const geo = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const treePos = [];
        const cloudPos = [];

        const colorGreen = COLORS.green;
        const colorGold = COLORS.gold;

        for(let i=0; i<particleCount; i++) {
            const t = i / particleCount;
            const angle = t * Math.PI * 40;
            const radius = t * 4;
            const height = (1 - t) * 12 - 6;

            const randomR = Math.random() * 0.5;
            const xTree = (radius + randomR) * Math.cos(angle);
            const zTree = (radius + randomR) * Math.sin(angle);
            const yTree = height;

            treePos.push(xTree, yTree, zTree);

            const xCloud = (Math.random() - 0.5) * 40;
            const yCloud = (Math.random() - 0.5) * 30;
            const zCloud = (Math.random() - 0.5) * 20 - 5;
            cloudPos.push(xCloud, yCloud, zCloud);

            positions.push(xTree, yTree, zTree);

            const mixedColor = Math.random() > 0.8 ? colorGold : colorGreen;
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
        }

        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.userData = { treePos: treePos, cloudPos: cloudPos };

        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pixelRatio: { value: window.devicePixelRatio },
                color: { value: new THREE.Color(0xffffff) }
            },
            vertexShader: `
                    uniform float time;
                    uniform float pixelRatio;
                    attribute vec3 color;
                    varying vec3 vColor;
                    void main() {
                        vColor = color;
                        vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (4.0 + 2.0 * sin(time * 2.0)) * pixelRatio * (50.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition;
                    }
                `,
            fragmentShader: `
                    varying vec3 vColor;
                    void main() {
                        vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        float strength = 1.0 - (length(coord) * 2.0);
                        strength = pow(strength, 1.5);
                        gl_FragColor = vec4(vColor, strength * 0.8);
                    }
                `,
            transparent: true,
            depthWrite: false,
            blending: THREE.AdditiveBlending
        });

        particles = new THREE.Points(geo, shaderMaterial);
        scene.add(particles);
    }

    // --- è£…é¥°ç‰© ---
    function createOrnaments() {
        const count = 200;
        const geom = new THREE.IcosahedronGeometry(0.2, 0);
        const mat = new THREE.MeshStandardMaterial({
            color: COLORS.red,
            roughness: 0.2,
            metalness: 0.8
        });
        ornamentsMesh = new THREE.InstancedMesh(geom, mat, count);
        const dummy = new THREE.Object3D();

        for(let i=0; i<count; i++) {
            const h = Math.random() * 10 - 5;
            const r = (5 - (h + 5)) * 0.4 + 0.5;
            const theta = Math.random() * Math.PI * 2;
            dummy.position.set(r * Math.cos(theta), h, r * Math.sin(theta));
            dummy.updateMatrix();
            ornamentsMesh.setMatrixAt(i, dummy.matrix);
        }
        scene.add(ornamentsMesh);
    }

    // --- æ‹ç«‹å¾—ç…§ç‰‡é€»è¾‘ ---
    function createPolaroid(texture, index) {
        const group = new THREE.Group();

        const frameGeo = new THREE.BoxGeometry(1.8, 2.2, 0.05);
        const frameMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
        const frame = new THREE.Mesh(frameGeo, frameMat);

        const photoGeo = new THREE.PlaneGeometry(1.6, 1.6);
        const photoMat = new THREE.MeshBasicMaterial({ map: texture });
        const photo = new THREE.Mesh(photoGeo, photoMat);
        photo.position.z = 0.03;
        photo.position.y = 0.2;

        const trimGeo = new THREE.PlaneGeometry(1.6, 0.02);
        const trimMat = new THREE.MeshStandardMaterial({ color: COLORS.gold, metalness: 1, roughness: 0.2 });
        const trim = new THREE.Mesh(trimGeo, trimMat);
        trim.position.set(0, -0.7, 0.04);

        group.add(frame);
        group.add(photo);
        group.add(trim);

        group.position.set(0, -100, 0);

        const totalPhotos = 50;
        const turns = 12;
        const angle = (index / totalPhotos) * Math.PI * 2 * turns;
        const normalizedH = (index / totalPhotos) * 12 - 6;
        const r = (6 - normalizedH) * 0.5;

        group.userData.treePos = {
            x: Math.cos(angle) * r,
            y: normalizedH,
            z: Math.sin(angle) * r,
            rotX: 0,
            rotY: -angle + Math.PI/2,
            rotZ: 0,
            scale: 0.35
        };

        return group;
    }

    function loadPhotos(urls) {
        const loader = new THREE.TextureLoader();
        photoMeshes.forEach(m => scene.remove(m));
        photoMeshes = [];
        photoMeshGroup = new THREE.Group();
        scene.add(photoMeshGroup);

        urls.forEach((url, index) => {
            loader.load(url, (tex) => {
                const mesh = createPolaroid(tex, index);
                photoMeshes.push(mesh);
                photoMeshGroup.add(mesh);
                mesh.position.set(
                    mesh.userData.treePos.x,
                    mesh.userData.treePos.y,
                    mesh.userData.treePos.z
                );
                mesh.rotation.y = mesh.userData.treePos.rotY;
                mesh.scale.set(0.35, 0.35, 0.35);
            });
        });
    }

    document.getElementById('file-input').addEventListener('change', function(e) {
        const files = e.target.files;
        if(files.length === 0) return;
        const newUrls = [];
        for(let i=0; i<files.length; i++) {
            newUrls.push(URL.createObjectURL(files[i]));
        }
        photoBatchIndex = 0;
        loadPhotos(newUrls);
    });

    // --- æ ¸å¿ƒï¼šçŠ¶æ€æœºä¸å¸ƒå±€è®¡ç®— (å¼ºåˆ¶æ‰‹æœºç«–å±ä¼˜åŒ–) ---
    function updateState(newState, force = false) {
        if (currentState === newState && !force) return;

        if (currentState === 'CLOUD' && newState === 'TREE') {
            photoBatchIndex = (photoBatchIndex + PHOTOS_PER_BATCH) % photoMeshes.length;
            document.getElementById('page-indicator').style.opacity = 0;
            document.getElementById('greeting-text').style.opacity = 1;
        }

        if (newState === 'CLOUD') {
            const pageNum = Math.floor(photoBatchIndex / PHOTOS_PER_BATCH) + 1;
            document.getElementById('page-indicator').innerText = `ç¬¬ ${pageNum} ç»„å›å¿†`;
            document.getElementById('page-indicator').style.opacity = 1;
            document.getElementById('greeting-text').style.opacity = 0;
        }

        currentState = newState;
        const duration = 1.2;
        const ease = "power2.inOut";

        const pPositions = particles.geometry.attributes.position.array;
        const targetKey = newState === 'TREE' ? 'treePos' : 'cloudPos';
        const targets = particles.geometry.userData[targetKey];
        const startPos = Float32Array.from(pPositions);
        const animObj = { val: 0 };

        gsap.to(animObj, {
            val: 1,
            duration: duration,
            ease: ease,
            onUpdate: () => {
                for(let i=0; i < pPositions.length; i++) {
                    pPositions[i] = startPos[i] + (targets[i] - startPos[i]) * animObj.val;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }
        });

        if(newState === 'TREE') {
            gsap.to(ornamentsMesh.scale, { x: 1, y: 1, z: 1, duration: duration });
            gsap.to(ornamentsMesh.position, { y: 0, duration: duration });
        } else {
            gsap.to(ornamentsMesh.scale, { x: 0, y: 0, z: 0, duration: duration });
        }

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šç…§ç‰‡å¸ƒå±€é€»è¾‘ ---
        const activeIndices = [];
        for(let i = 0; i < PHOTOS_PER_BATCH; i++) {
            activeIndices.push((photoBatchIndex + i) % photoMeshes.length);
        }

        // å¼ºåˆ¶ä½¿ç”¨ç«–å±é€»è¾‘ (å› ä¸ºä½ ä¸»è¦ç”¨æ‰‹æœº)
        // å›ºå®š 2 åˆ—
        const cols = 2;

        // é—´è·å’Œä½ç½®å‚æ•°ä¼˜åŒ–
        const spacingX = 4.2; // ç¨å¾®ç´§å‡‘ä¸€ç‚¹
        const spacingY = 5.5;

        // é‡è¦ï¼šæŠŠç…§ç‰‡å¾€é‡Œæ¨ (Z=0)ï¼Œä¸è¦å¤ªé è¿‘ç›¸æœº
        // ç›¸æœºåœ¨ Z=24ï¼Œç…§ç‰‡åœ¨ Z=0ï¼Œè·ç¦»è¶³å¤Ÿè¿œï¼Œè§†é‡è¶³å¤Ÿå¤§
        const targetZ = 0;
        const targetScale = 1.2;

        photoMeshes.forEach((mesh, index) => {
            let target = {};

            if (newState === 'TREE') {
                target = {
                    x: mesh.userData.treePos.x,
                    y: mesh.userData.treePos.y,
                    z: mesh.userData.treePos.z,
                    rotX: 0,
                    rotY: mesh.userData.treePos.rotY,
                    rotZ: 0,
                    scale: 0.35
                };
            } else {
                const slotIndex = activeIndices.indexOf(index);

                if (slotIndex !== -1) {
                    const col = slotIndex % cols;
                    const row = Math.floor(slotIndex / cols);

                    const startX = -((cols - 1) * spacingX) / 2;
                    const rowsTotal = Math.ceil(PHOTOS_PER_BATCH / cols);
                    const startY = ((rowsTotal - 1) * spacingY) / 2;

                    target = {
                        x: startX + col * spacingX,
                        // ç¨å¾®åŠ ä¸€ç‚¹ offsetY é¿å…è¢«åº•éƒ¨æ–‡å­—æŒ¡ä½
                        y: startY - row * spacingY + 1.5,
                        z: targetZ,
                        rotX: 0,
                        rotY: 0,
                        rotZ: 0,
                        scale: targetScale
                    };
                } else {
                    target = {
                        x: mesh.userData.treePos.x * 5,
                        y: mesh.userData.treePos.y * 5,
                        z: -20,
                        rotX: 0, rotY: 0, rotZ: 0,
                        scale: 0
                    };
                }
            }

            gsap.to(mesh.position, {
                x: target.x,
                y: target.y,
                z: target.z,
                duration: duration,
                ease: ease
            });
            gsap.to(mesh.rotation, {
                x: target.rotX,
                y: target.rotY,
                z: target.rotZ,
                duration: duration,
                ease: ease
            });
            gsap.to(mesh.scale, {
                x: target.scale,
                y: target.scale,
                z: target.scale,
                duration: duration,
                ease: ease
            });
        });
    }

    const videoElement = document.getElementsByClassName('input_video')[0];

    function onResults(results) {
        document.getElementById('loading-text').style.display = 'none';
        document.getElementById('instructions').style.opacity = 1;
        document.querySelector('.input_video').style.display = 'block';

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20].map(i => landmarks[i]);
            const dist = tips.reduce((acc, t) => acc + d(wrist, t), 0) / 4;

            let gesture = 'UNKNOWN';
            if (dist < 0.25) gesture = 'FIST';
            else if (dist > 0.4) gesture = 'OPEN';

            const now = Date.now();
            if (now - gestureDebounce > 500) {
                if (gesture === 'FIST' && lastGesture !== 'FIST') {
                    updateState('TREE');
                    gestureDebounce = now;
                } else if (gesture === 'OPEN' && currentState === 'TREE') {
                    updateState('CLOUD');
                    gestureDebounce = now;
                }
                if (gesture !== 'UNKNOWN') lastGesture = gesture;
            }
        }
    }

    function d(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
    hands.onResults(onResults);

    async function startCamera() {
        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            showError("æ‚¨çš„æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´è®¿é—®ã€‚");
            return;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: "user" }
            });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                isCameraRunning = true;
                processVideoLoop();
            };
        } catch (error) {
            console.error(error);
            showError("æ— æ³•è®¿é—®æ‘„åƒå¤´ï¼Œè¯·æ£€æŸ¥æƒé™ã€‚");
        }
    }

    function showError(msg) {
        document.getElementById('loading-text').innerHTML = msg;
    }

    async function processVideoLoop() {
        if (!isCameraRunning) return;
        if (videoElement.readyState >= 2) {
            try { await hands.send({image: videoElement}); } catch (e) {}
        }
        requestAnimationFrame(processVideoLoop);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        if(particles && particles.material.uniforms) particles.material.uniforms.time.value = time;

        if (currentState === 'TREE' && scene) scene.rotation.y = time * 0.1;
        if (currentState === 'CLOUD' && scene) scene.rotation.y = Math.sin(time * 0.2) * 0.02;

        updateSnow();
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if(particles) particles.material.uniforms.pixelRatio.value = window.devicePixelRatio;

        if(currentState === 'CLOUD') updateState('CLOUD', true);
    }

    init();
</script>
</body>
</html>