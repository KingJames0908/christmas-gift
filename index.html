<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Our Christmas Memory | æˆ‘ä»¬çš„ä¸“å±åœ£è¯æ ‘</title>
    <!-- å¼•å…¥æµªæ¼«å­—ä½“ -->
    <link href="https://fonts.googleapis.com/css2?family=Dancing+Script:wght@700&family=Noto+Serif+SC:wght@700&display=swap" rel="stylesheet">
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'PingFang SC', 'Microsoft YaHei', sans-serif;
            user-select: none;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 1;
        }

        /* æ‘„åƒå¤´é¢„è§ˆ */
        .input_video {
            position: absolute;
            bottom: 10px;
            right: 10px;
            width: 100px;
            height: 75px;
            border-radius: 8px;
            border: 2px solid rgba(255, 215, 0, 0.3);
            z-index: 10;
            opacity: 0.6;
            transform: scaleX(-1); /* é•œåƒ */
            display: none;
            object-fit: cover;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 999; /* æé«˜å±‚çº§ï¼Œè¦†ç›–ä¸€åˆ‡ç›´åˆ°åŠ è½½å®Œæˆ */
            background-color: #000; /* çº¯é»‘èƒŒæ™¯é®æŒ¡ */
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 1s ease-out; /* æ·¡å‡ºæ•ˆæœ */
        }

        /* è¿›åº¦æ¡å®¹å™¨ */
        .progress-container {
            width: 80%;
            max-width: 300px;
            height: 4px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 2px;
            margin-bottom: 20px;
            position: relative;
            overflow: hidden;
        }

        /* è¿›åº¦æ¡æœ¬ä½“ */
        .progress-bar {
            width: 0%;
            height: 100%;
            background: linear-gradient(90deg, #FFD700, #ff6b6b);
            box-shadow: 0 0 10px #FFD700;
            border-radius: 2px;
            transition: width 0.1s linear; /* å¹³æ»‘è¿‡æ¸¡ */
        }

        /* åŠ è½½æ–‡å­— */
        .loading-text {
            color: #FFD700;
            font-size: 16px;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
            font-family: 'Noto Serif SC', serif;
            animation: breathe 2s infinite ease-in-out;
        }

        @keyframes breathe {
            0%, 100% { opacity: 0.6; }
            50% { opacity: 1; }
        }

        /* ä¸“å±ç¥ç¦è¯­æ ·å¼ (ä¸»ç•Œé¢æ˜¾ç¤º) */
        #greeting-text {
            position: absolute;
            top: 18%;
            width: 90%;
            left: 5%;
            text-align: center;
            font-family: 'Dancing Script', 'Noto Serif SC', serif;
            font-size: 2.2rem;
            line-height: 1.4;
            color: #FFD700;
            text-shadow:
                    0 0 10px rgba(255, 215, 0, 0.8),
                    0 0 20px rgba(255, 69, 0, 0.4);
            background: linear-gradient(to bottom, #FFD700, #F0E68C);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            opacity: 0; /* åˆå§‹éšè—ï¼Œç­‰åŠ è½½å®Œæ˜¾ç¤º */
            transition: opacity 1.5s ease-in-out;
            z-index: 6;
            pointer-events: none;
        }

        /* å·¦ä¸Šè§’æŒ‡å¼• (æ–°éœ€æ±‚) */
        #guide-overlay {
            position: absolute;
            top: 20px;
            left: 20px;
            color: rgba(255, 255, 255, 0.6);
            font-size: 12px;
            line-height: 1.8;
            z-index: 5;
            opacity: 0; /* åˆå§‹éšè— */
            transition: opacity 1s;
            pointer-events: none;
            background: rgba(0,0,0,0.3);
            padding: 8px 12px;
            border-radius: 8px;
            border: 1px solid rgba(255, 255, 255, 0.1);
        }
        #guide-overlay b {
            color: #FFD700;
            font-size: 14px;
        }

        /* é¡µç æç¤º */
        #page-indicator {
            position: absolute;
            top: 12%;
            left: 50%;
            transform: translateX(-50%);
            color: rgba(255, 215, 0, 0.8);
            font-size: 16px;
            opacity: 0;
            transition: opacity 0.5s;
            z-index: 5;
            letter-spacing: 2px;
            text-shadow: 0 0 5px rgba(255, 215, 0, 0.5);
        }

        /* éšè—æ–‡ä»¶è¾“å…¥ */
        #file-input { display: none; }
        #upload-btn { display: none; } /* æ—¢ç„¶æ˜¯ç»™å¥³æœ‹å‹çœ‹ï¼Œä¸Šä¼ æŒ‰é’®å¯ä»¥éšè—äº† */
    </style>
</head>
<body>

<!-- è§†é¢‘è¾“å…¥æµ -->
<video class="input_video" playsinline autoplay muted></video>

<!-- 3D å®¹å™¨ -->
<div id="canvas-container"></div>

<!-- 1. åŠ è½½å±‚ (è¿›åº¦æ¡) -->
<div id="ui-layer">
    <div class="progress-container">
        <div class="progress-bar" id="progress-bar"></div>
    </div>
    <div class="loading-text">æ­£åœ¨åŠ è½½å›å¿†ï¼Œä¹–ä¹–è€å©†åˆ«æ€¥å“¦...</div>
</div>

<!-- 2. ä¸»ç•Œé¢ UI -->
<!-- å·¦ä¸Šè§’æŒ‡å¼• -->
<div id="guide-overlay">
    âœŠ <b>æ¡æ‹³</b>ï¼šå±•ç¤ºåœ£è¯æ ‘<br>
    ğŸ–ï¸ <b>å¼ æ‰‹</b>ï¼šå±•å¼€å›å¿†
</div>

<!-- ç¥ç¦è¯­ -->
<div id="greeting-text">ç¥æˆ‘çš„è€å©†-å©§å®<br>åœ£è¯èŠ‚å¿«ä¹</div>

<div id="page-indicator">ç¬¬ 1 ç»„å›å¿†</div>

<!-- éšè—çš„ä¸Šä¼ åŠŸèƒ½ -->
<input type="file" id="file-input" multiple accept="image/*">

<!-- å¼•å…¥åº“ -->
<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>
<!-- MediaPipe Hands -->
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
<script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

<script>
    // --- ç”¨æˆ·é…ç½®åŒº ---
    const BASE_PHOTOS = [
        'IMG_20250817_212036.jpg', 'IMG_20250818_203221.jpg', 'IMG_20250818_203308.jpg',
        'IMG_20250823_155336.jpg', 'IMG_20250826_093345_1.jpg', 'IMG_20250826_141047.jpg',
        'IMG_20250828_121826.jpg', 'IMG_20250828_133111.jpg', 'IMG_20250828_192257.jpg',
        'IMG_20250828_192318_2.jpg', 'IMG_20250828_213506.jpg', 'IMG_20250828_213537.jpg',
        'IMG_20250828_214233.jpg', 'IMG_20250829_195014.jpg', 'IMG_20250830_094313.jpg',
        'IMG_20250830_115701_1.jpg', 'IMG_20250830_134306.jpg', 'IMG_20250831_122417_1.jpg',
        'IMG_20250901_072530.jpg', 'IMG_20250901_170634.jpg', 'IMG_20250910_132832.jpg',
        'IMG_20250913_155149.jpg', 'IMG_20250913_202314.jpg', 'IMG_20250913_235210.jpg',
        'IMG_20250914_123038.jpg', 'IMG_20250914_140112.jpg', 'IMG_20250914_173305.jpg',
        'IMG_20250914_193830.jpg', 'IMG_20250914_200834.jpg', 'IMG_20250914_200841.jpg',
        'IMG_20250915_191124.jpg', 'IMG_20250915_191130.jpg', 'IMG_20250915_191205.jpg',
        'IMG_20250915_192632.jpg', 'IMG_20250915_192726.jpg', 'IMG_20250915_221557_1.jpg',
        'IMG_20250915_221722.jpg', 'IMG_20250915_222110.jpg', 'IMG_20250916_012235.jpg',
        'IMG_20250916_143843.jpg', 'IMG_20250916_155806.jpg', 'IMG_20250916_161514.jpg',
        'IMG_20250916_184105.jpg', 'IMG_20250917_164532.jpg', 'IMG_20251002_095148.jpg',
        'IMG_20251002_163205.jpg', 'IMG_20251002_171104.jpg', 'IMG_20251002_180259_1.jpg',
        'IMG_20251005_130418.jpg', 'IMG_20251006_105451.jpg'
    ];
    const PRELOADED_PHOTOS = BASE_PHOTOS;

    // --- å…¨å±€å˜é‡ ---
    let scene, camera, renderer, clock;
    let particles, geometry, material;
    let photoMeshGroup = new THREE.Group();
    let photoMeshes = [];
    let currentState = 'TREE'; // 'TREE', 'CLOUD'

    let photoBatchIndex = 0;
    const PHOTOS_PER_BATCH = 6;

    let ornamentsMesh;
    let lastGesture = 'NONE';
    let gestureDebounce = 0;
    let isCameraRunning = false;

    // åŠ è½½çŠ¶æ€æ§åˆ¶
    let isTimeUp = false; // 30s å€’è®¡æ—¶æ˜¯å¦ç»“æŸ
    let isAssetsLoaded = false; // èµ„æºæ˜¯å¦åŠ è½½å®Œ
    let hasStarted = false; // æ˜¯å¦å·²ç»è¿›å…¥ä¸»ç¨‹åº

    const COLORS = {
        green: new THREE.Color(0x2F5A3F),
        gold: new THREE.Color(0xFFD700),
        red: new THREE.Color(0xB22222),
        snow: new THREE.Color(0xFFFFFF)
    };

    // --- æ ¸å¿ƒä¿®æ”¹ï¼š30ç§’åŠ è½½é€»è¾‘ ---
    function startLoadingSequence() {
        const bar = document.getElementById('progress-bar');
        // ä½¿ç”¨ GSAP è®©è¿›åº¦æ¡åœ¨ 30ç§’å†… èµ°åˆ° 100%
        gsap.to(bar, {
            width: "100%",
            duration: 30, // å¼ºåˆ¶ 30 ç§’
            ease: "linear",
            onComplete: () => {
                isTimeUp = true;
                checkAllReady();
            }
        });
    }

    // æ£€æŸ¥æ˜¯å¦æ‰€æœ‰æ¡ä»¶éƒ½æ»¡è¶³ï¼ˆæ—¶é—´åˆ° + å›¾ç‰‡å¥½ + æ‘„åƒå¤´å¥½ï¼‰
    function checkAllReady() {
        if (isTimeUp && isAssetsLoaded && isCameraRunning && !hasStarted) {
            hasStarted = true;
            // æ·¡å‡ºåŠ è½½å±‚
            const ui = document.getElementById('ui-layer');
            ui.style.opacity = 0;
            setTimeout(() => {
                ui.style.display = 'none';
            }, 1000);

            // æ˜¾ç¤ºä¸»ç•Œé¢å…ƒç´ 
            document.getElementById('greeting-text').style.opacity = 1;
            document.getElementById('guide-overlay').style.opacity = 1;
            document.querySelector('.input_video').style.display = 'block';
        }
    }

    // --- åˆå§‹åŒ– Three.js ---
    function init() {
        const container = document.getElementById('canvas-container');

        scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x050510, 0.02);
        scene.background = new THREE.Color(0x050510);

        camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);

        // æ‘„åƒæœºä½ç½®
        if(window.innerWidth < window.innerHeight) {
            camera.position.set(0, 0, 24);
        } else {
            camera.position.set(0, 0, 16);
        }

        renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.shadowMap.enabled = true;
        container.appendChild(renderer.domElement);

        clock = new THREE.Clock();

        // ç¯å…‰
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
        scene.add(ambientLight);
        const pointLight = new THREE.PointLight(0xFFD700, 1, 50);
        pointLight.position.set(5, 10, 5);
        scene.add(pointLight);
        const spotLight = new THREE.SpotLight(0xff0000, 2);
        spotLight.position.set(-5, 10, 0);
        scene.add(spotLight);

        // åˆ›å»ºåœºæ™¯å…ƒç´ 
        createSnow();
        createTreeParticles();
        createOrnaments();
        loadPhotos(PRELOADED_PHOTOS); // å¯åŠ¨å›¾ç‰‡åŠ è½½

        window.addEventListener('resize', onWindowResize, false);
        animate();
        startCamera(); // å¯åŠ¨æ‘„åƒå¤´
        startLoadingSequence(); // å¯åŠ¨30så€’è®¡æ—¶
    }

    // --- 5B: é£˜é›ªå†¬å¤œ ---
    let snowSystem;
    function createSnow() {
        const snowCount = 2000;
        const snowGeo = new THREE.BufferGeometry();
        const positions = [];
        const velocities = [];
        for(let i=0; i<snowCount; i++) {
            positions.push((Math.random()-0.5)*50, Math.random()*30, (Math.random()-0.5)*50);
            velocities.push((Math.random()-0.5)*0.05, -(Math.random()*0.05+0.02), (Math.random()-0.5)*0.05);
        }
        snowGeo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        snowGeo.userData = { velocities: velocities };

        const canvas = document.createElement('canvas');
        canvas.width = 32; canvas.height = 32;
        const ctx = canvas.getContext('2d');
        ctx.beginPath();
        ctx.arc(16, 16, 10, 0, 2 * Math.PI);
        ctx.fillStyle = '#ffffff';
        ctx.fill();
        const texture = new THREE.CanvasTexture(canvas);

        const snowMat = new THREE.PointsMaterial({
            color: 0xffffff, size: 0.2, map: texture, transparent: true, opacity: 0.6,
            depthWrite: false, blending: THREE.AdditiveBlending
        });
        snowSystem = new THREE.Points(snowGeo, snowMat);
        scene.add(snowSystem);
    }

    function updateSnow() {
        if(!snowSystem) return;
        const positions = snowSystem.geometry.attributes.position.array;
        const vels = snowSystem.geometry.userData.velocities;
        for(let i=0; i < positions.length / 3; i++) {
            positions[i*3] += vels[i*3];
            positions[i*3+1] += vels[i*3+1];
            positions[i*3+2] += vels[i*3+2];
            if(positions[i*3+1] < -10) positions[i*3+1] = 20;
        }
        snowSystem.geometry.attributes.position.needsUpdate = true;
    }

    // --- 4B: ç²’å­æ˜Ÿå°˜æ ‘ ---
    function createTreeParticles() {
        const particleCount = 3000;
        const geo = new THREE.BufferGeometry();
        const positions = [];
        const colors = [];
        const treePos = []; const cloudPos = [];
        const colorGreen = COLORS.green; const colorGold = COLORS.gold;

        for(let i=0; i<particleCount; i++) {
            const t = i / particleCount;
            const angle = t * Math.PI * 40;
            const radius = t * 4;
            const height = (1 - t) * 12 - 6;
            const randomR = Math.random() * 0.5;
            const xTree = (radius + randomR) * Math.cos(angle);
            const zTree = (radius + randomR) * Math.sin(angle);
            const yTree = height;
            treePos.push(xTree, yTree, zTree);
            const xCloud = (Math.random() - 0.5) * 40;
            const yCloud = (Math.random() - 0.5) * 30;
            const zCloud = (Math.random() - 0.5) * 20 - 5;
            cloudPos.push(xCloud, yCloud, zCloud);
            positions.push(xTree, yTree, zTree);
            const mixedColor = Math.random() > 0.8 ? colorGold : colorGreen;
            colors.push(mixedColor.r, mixedColor.g, mixedColor.b);
        }
        geo.setAttribute('position', new THREE.Float32BufferAttribute(positions, 3));
        geo.setAttribute('color', new THREE.Float32BufferAttribute(colors, 3));
        geo.userData = { treePos: treePos, cloudPos: cloudPos };

        const shaderMaterial = new THREE.ShaderMaterial({
            uniforms: {
                time: { value: 0 },
                pixelRatio: { value: window.devicePixelRatio },
                color: { value: new THREE.Color(0xffffff) }
            },
            vertexShader: `
                    uniform float time; uniform float pixelRatio; attribute vec3 color; varying vec3 vColor;
                    void main() { vColor = color; vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                        gl_PointSize = (4.0 + 2.0 * sin(time * 2.0)) * pixelRatio * (50.0 / -mvPosition.z);
                        gl_Position = projectionMatrix * mvPosition; }
                `,
            fragmentShader: `
                    varying vec3 vColor; void main() { vec2 coord = gl_PointCoord - vec2(0.5);
                        if(length(coord) > 0.5) discard;
                        float strength = 1.0 - (length(coord) * 2.0); strength = pow(strength, 1.5);
                        gl_FragColor = vec4(vColor, strength * 0.8); }
                `,
            transparent: true, depthWrite: false, blending: THREE.AdditiveBlending
        });
        particles = new THREE.Points(geo, shaderMaterial);
        scene.add(particles);
    }

    // --- è£…é¥°ç‰© ---
    function createOrnaments() {
        const count = 200;
        const geom = new THREE.IcosahedronGeometry(0.2, 0);
        const mat = new THREE.MeshStandardMaterial({ color: COLORS.red, roughness: 0.2, metalness: 0.8 });
        ornamentsMesh = new THREE.InstancedMesh(geom, mat, count);
        const dummy = new THREE.Object3D();
        for(let i=0; i<count; i++) {
            const h = Math.random() * 10 - 5;
            const r = (5 - (h + 5)) * 0.4 + 0.5;
            const theta = Math.random() * Math.PI * 2;
            dummy.position.set(r * Math.cos(theta), h, r * Math.sin(theta));
            dummy.updateMatrix();
            ornamentsMesh.setMatrixAt(i, dummy.matrix);
        }
        scene.add(ornamentsMesh);
    }

    // --- æ‹ç«‹å¾—ç…§ç‰‡é€»è¾‘ ---
    function createPolaroid(texture, index) {
        const group = new THREE.Group();
        const frameGeo = new THREE.BoxGeometry(1.8, 2.2, 0.05);
        const frameMat = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.6 });
        const frame = new THREE.Mesh(frameGeo, frameMat);
        const photoGeo = new THREE.PlaneGeometry(1.6, 1.6);
        const photoMat = new THREE.MeshBasicMaterial({ map: texture });
        const photo = new THREE.Mesh(photoGeo, photoMat);
        photo.position.z = 0.03; photo.position.y = 0.2;
        const trimGeo = new THREE.PlaneGeometry(1.6, 0.02);
        const trimMat = new THREE.MeshStandardMaterial({ color: COLORS.gold, metalness: 1, roughness: 0.2 });
        const trim = new THREE.Mesh(trimGeo, trimMat);
        trim.position.set(0, -0.7, 0.04);
        group.add(frame); group.add(photo); group.add(trim);
        group.position.set(0, -100, 0);

        const totalPhotos = 50;
        const turns = 12;
        const angle = (index / totalPhotos) * Math.PI * 2 * turns;
        const normalizedH = (index / totalPhotos) * 12 - 6;
        const r = (6 - normalizedH) * 0.5;

        group.userData.treePos = {
            x: Math.cos(angle) * r, y: normalizedH, z: Math.sin(angle) * r,
            rotX: 0, rotY: -angle + Math.PI/2, rotZ: 0, scale: 0.35
        };
        return group;
    }

    // --- æ ¸å¿ƒä¿®æ”¹ï¼šçœŸæ­£çš„å›¾ç‰‡åŠ è½½æ£€æµ‹ ---
    function loadPhotos(urls) {
        const loader = new THREE.TextureLoader();
        photoMeshes.forEach(m => scene.remove(m));
        photoMeshes = [];
        photoMeshGroup = new THREE.Group();
        scene.add(photoMeshGroup);

        let loadedCount = 0; // å·²åŠ è½½æ•°é‡

        urls.forEach((url, index) => {
            loader.load(url, (tex) => {
                const mesh = createPolaroid(tex, index);
                photoMeshes.push(mesh);
                photoMeshGroup.add(mesh);
                mesh.position.set(mesh.userData.treePos.x, mesh.userData.treePos.y, mesh.userData.treePos.z);
                mesh.rotation.y = mesh.userData.treePos.rotY;
                mesh.scale.set(0.35, 0.35, 0.35);

                // è®¡æ•°
                loadedCount++;
                if (loadedCount === urls.length) {
                    isAssetsLoaded = true;
                    console.log("æ‰€æœ‰å›¾ç‰‡åŠ è½½å®Œæ¯•!");
                    checkAllReady(); // å°è¯•è¿›å…¥ä¸»ç•Œé¢
                }
            }, undefined, (err) => {
                console.error("å›¾ç‰‡åŠ è½½å¤±è´¥:", url);
                // å³ä½¿å¤±è´¥ä¹Ÿè¦è®¡æ•°ï¼Œé˜²æ­¢å¡æ­»
                loadedCount++;
                if (loadedCount === urls.length) {
                    isAssetsLoaded = true;
                    checkAllReady();
                }
            });
        });
    }

    // --- æ ¸å¿ƒï¼šçŠ¶æ€æœºä¸å¸ƒå±€è®¡ç®— (å¼ºåˆ¶æ‰‹æœºç«–å±ä¼˜åŒ–) ---
    function updateState(newState, force = false) {
        if (currentState === newState && !force) return;

        if (currentState === 'CLOUD' && newState === 'TREE') {
            photoBatchIndex = (photoBatchIndex + PHOTOS_PER_BATCH) % photoMeshes.length;
            document.getElementById('page-indicator').style.opacity = 0;
            document.getElementById('greeting-text').style.opacity = 1;
        }

        if (newState === 'CLOUD') {
            const pageNum = Math.floor(photoBatchIndex / PHOTOS_PER_BATCH) + 1;
            document.getElementById('page-indicator').innerText = `ç¬¬ ${pageNum} ç»„å›å¿†`;
            document.getElementById('page-indicator').style.opacity = 1;
            document.getElementById('greeting-text').style.opacity = 0;
        }

        currentState = newState;
        const duration = 1.2;
        const ease = "power2.inOut";

        const pPositions = particles.geometry.attributes.position.array;
        const targetKey = newState === 'TREE' ? 'treePos' : 'cloudPos';
        const targets = particles.geometry.userData[targetKey];
        const startPos = Float32Array.from(pPositions);
        const animObj = { val: 0 };

        gsap.to(animObj, {
            val: 1, duration: duration, ease: ease,
            onUpdate: () => {
                for(let i=0; i < pPositions.length; i++) {
                    pPositions[i] = startPos[i] + (targets[i] - startPos[i]) * animObj.val;
                }
                particles.geometry.attributes.position.needsUpdate = true;
            }
        });

        if(newState === 'TREE') {
            gsap.to(ornamentsMesh.scale, { x: 1, y: 1, z: 1, duration: duration });
            gsap.to(ornamentsMesh.position, { y: 0, duration: duration });
        } else {
            gsap.to(ornamentsMesh.scale, { x: 0, y: 0, z: 0, duration: duration });
        }

        // --- æ ¸å¿ƒä¿®æ”¹ï¼šç…§ç‰‡å¸ƒå±€é€»è¾‘ (æ”¾å¤§ç‰ˆ) ---
        const activeIndices = [];
        for(let i = 0; i < PHOTOS_PER_BATCH; i++) {
            activeIndices.push((photoBatchIndex + i) % photoMeshes.length);
        }

        const cols = 2;

        // --- [å¯è°ƒèŠ‚å‚æ•°] å¦‚æœè¿˜å«Œå°ï¼Œå¯ä»¥ç»§ç»­æ”¹è¿™é‡Œ ---
        const spacingX = 6.0; // åŸ 4.2 -> 6.0 (æ‹‰å¤§æ¨ªå‘é—´è·)
        const spacingY = 8.0; // åŸ 5.5 -> 8.0 (æ‹‰å¤§çºµå‘é—´è·)
        const targetScale = 3.2; // åŸ 1.2 -> 3.2 (å¤§å¹…æ”¾å¤§ç…§ç‰‡)
        // ---------------------------------------------

        // ç…§ç‰‡Zè½´ä½ç½®ï¼Œ0è¡¨ç¤ºåœ¨ä¸–ç•Œä¸­å¿ƒï¼Œç¦»ç›¸æœº(Z=24)æœ‰ä¸€å®šè·ç¦»ï¼Œä¿è¯ä¸è´´è„¸
        const targetZ = 0;

        photoMeshes.forEach((mesh, index) => {
            let target = {};

            if (newState === 'TREE') {
                target = {
                    x: mesh.userData.treePos.x,
                    y: mesh.userData.treePos.y,
                    z: mesh.userData.treePos.z,
                    rotX: 0, rotY: mesh.userData.treePos.rotY, rotZ: 0,
                    scale: 0.35
                };
            } else {
                const slotIndex = activeIndices.indexOf(index);

                if (slotIndex !== -1) {
                    const col = slotIndex % cols;
                    const row = Math.floor(slotIndex / cols);

                    const startX = -((cols - 1) * spacingX) / 2;
                    const rowsTotal = Math.ceil(PHOTOS_PER_BATCH / cols);
                    const startY = ((rowsTotal - 1) * spacingY) / 2;

                    target = {
                        x: startX + col * spacingX,
                        y: startY - row * spacingY + 1.5,
                        z: targetZ,
                        rotX: 0, rotY: 0, rotZ: 0,
                        scale: targetScale
                    };
                } else {
                    target = {
                        x: mesh.userData.treePos.x * 5, y: mesh.userData.treePos.y * 5, z: -20,
                        rotX: 0, rotY: 0, rotZ: 0, scale: 0
                    };
                }
            }

            gsap.to(mesh.position, { x: target.x, y: target.y, z: target.z, duration: duration, ease: ease });
            gsap.to(mesh.rotation, { x: target.rotX, y: target.rotY, z: target.rotZ, duration: duration, ease: ease });
            gsap.to(mesh.scale, { x: target.scale, y: target.scale, z: target.scale, duration: duration, ease: ease });
        });
    }

    const videoElement = document.getElementsByClassName('input_video')[0];

    function onResults(results) {
        // æ³¨æ„ï¼šè¿™é‡Œåˆ é™¤äº†åŸæ¥éšè—loadingçš„ä»£ç 
        // ç°åœ¨loadingçš„éšè—å®Œå…¨ç”± checkAllReady() æ§åˆ¶

        if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
            const landmarks = results.multiHandLandmarks[0];
            const wrist = landmarks[0];
            const tips = [8, 12, 16, 20].map(i => landmarks[i]);
            const dist = tips.reduce((acc, t) => acc + d(wrist, t), 0) / 4;

            let gesture = 'UNKNOWN';
            if (dist < 0.28) gesture = 'FIST'; // è°ƒå®½é˜ˆå€¼
            else if (dist > 0.38) gesture = 'OPEN'; // è°ƒå®½é˜ˆå€¼

            const now = Date.now();
            if (now - gestureDebounce > 500) {
                if (gesture === 'FIST' && lastGesture !== 'FIST') {
                    updateState('TREE');
                    gestureDebounce = now;
                } else if (gesture === 'OPEN' && currentState === 'TREE') {
                    updateState('CLOUD');
                    gestureDebounce = now;
                }
                if (gesture !== 'UNKNOWN') lastGesture = gesture;
            }
        }
    }

    function d(p1, p2) {
        return Math.sqrt(Math.pow(p1.x - p2.x, 2) + Math.pow(p1.y - p2.y, 2));
    }

    const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
    hands.setOptions({ maxNumHands: 1, modelComplexity: 1, minDetectionConfidence: 0.4, minTrackingConfidence: 0.5 }); // é™ä½ç½®ä¿¡åº¦
    hands.onResults(onResults);

    async function startCamera() {
        if (!window.isSecureContext) {
            console.warn("éå®‰å…¨ç¯å¢ƒï¼Œæ‘„åƒå¤´å¯èƒ½æ— æ³•å¯åŠ¨");
            // å³ä½¿æ‘„åƒå¤´å¤±è´¥ï¼Œæˆ‘ä»¬ä¹Ÿå¯ä»¥å‡è£…å¯åŠ¨æˆåŠŸï¼Œæˆ–è€…æ˜¾ç¤ºé”™è¯¯
            // è¿™é‡Œä¸ºäº†ç¤¼ç‰©ä½“éªŒï¼Œå¦‚æœå¤±è´¥å°±ä¸é˜»å¡ï¼Œåªä¾èµ–å›¾ç‰‡åŠ è½½å’Œæ—¶é—´
        }

        if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
            console.warn("æµè§ˆå™¨ä¸æ”¯æŒæ‘„åƒå¤´");
            return;
        }
        try {
            const stream = await navigator.mediaDevices.getUserMedia({
                video: { width: { ideal: 640 }, height: { ideal: 480 }, facingMode: "user" }
            });
            videoElement.srcObject = stream;
            videoElement.onloadedmetadata = () => {
                videoElement.play();
                isCameraRunning = true;
                console.log("æ‘„åƒå¤´å¯åŠ¨æˆåŠŸ");
                checkAllReady(); // å°è¯•æ£€æµ‹æ˜¯å¦å¯ä»¥è¿›å…¥
                processVideoLoop(); // å¯åŠ¨å¾ªç¯!
            };
        } catch (error) {
            console.error("æ‘„åƒå¤´å¯åŠ¨å¤±è´¥:", error);
            // å®¹é”™å¤„ç†ï¼šå¦‚æœæ‘„åƒå¤´åäº†ï¼Œ30ç§’åä¹Ÿå¼ºåˆ¶è¿›å…¥ï¼Œè™½ç„¶ä¸èƒ½æ‰‹åŠ¿æ§åˆ¶ï¼Œä½†è‡³å°‘èƒ½çœ‹æ ‘
            isCameraRunning = true;
        }
    }

    function showError(msg) {
        // Loading text handles errors nicely now
        console.error(msg);
    }

    async function processVideoLoop() {
        if (!isCameraRunning) return;
        if (videoElement.readyState >= 2) {
            try { await hands.send({image: videoElement}); } catch (e) {}
        }
        requestAnimationFrame(processVideoLoop);
    }

    function animate() {
        requestAnimationFrame(animate);
        const time = clock.getElapsedTime();
        if(particles && particles.material.uniforms) particles.material.uniforms.time.value = time;

        if (currentState === 'TREE' && scene) scene.rotation.y = time * 0.1;
        if (currentState === 'CLOUD' && scene) scene.rotation.y = Math.sin(time * 0.2) * 0.02;

        updateSnow();
        renderer.render(scene, camera);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
        if(particles) particles.material.uniforms.pixelRatio.value = window.devicePixelRatio;

        if(currentState === 'CLOUD') updateState('CLOUD', true);
    }

    init();
</script>
</body>
</html>